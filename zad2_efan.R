#Ефанова Евгения 125 ПАЭ 
#Создайте модель множественной линейной регрессии потоков паров воды за летний период 2013 года 
#по данным измерений методом турбулентной пульсации

#Настройка и проверка рабочей директории
setwd("D:/Group_125/Efanova/MathMod")
getwd()

#Подключим нужные пакеты
library(rnoaa)
library(tidyverse)
library(lubridate)
library(tidyr)
library(stringr)
library(dplyr)
library(tibble)
library(readr)

#1.Подготовка данных 
#Воспользуемся функцией read_csv из пакета readr. Она во многои сходна с хорошо известной вам 
#read.csv, но обладает рядом полезных параметров, которые мы попытаемся для себя использовать
tbl = read_csv("https://www.dropbox.com/s/erhs9hoj4vhrz0b/eddypro.csv?dl=1")
tbl
#Первое на что вы должны обратить внимание, это то, что полученный в результате объект не является 
#привычным нам data.frame, а некой новой структурой типа tibble. Точнее, на самом деле он является и 
#data.frame тоже и в этом легко убедиться:
class(tbl)
#Представим нашу таблицу, пропустив 1 и 3 строчки, а также заменив значения -9999 символом NA
tbl = read_csv("eddypro.csv", skip = 1, na =c("","NA","-9999","-9999.0"), comment=c("["))
tbl
#Теперь данные имеют адекватный вид и мы сделали все, что можно еще на стадии их прочтения. Давайте 
#внимательнее посмотрим на сами переменные и для этого воспользуеся функцией glimpse(), которая более 
#наглядно представляет каждую отдельную переменную, жертdуя при этом предсталениеv строчек данных
glimpse(tbl)
#При внимательном рассмотрении можно заметить, что переменная roll содержит только NA, а потому будет 
#только мешать нам при анализе. Избавимся от нее с помощью функции select:
tbl = select(tbl, -(roll))
tbl
#В нашей таблице довольно много переменных типа char, которые содержат повторяющиеся значения, т.к. 
#их текст, как таковой нас не интересует, преобразуем их все в факторы:
tbl = tbl %>% mutate_if(is.character, factor)
#Здесь мы использовали функию mutate_if которая делает преобразование над колонкой - factor() при 
#полученни значения TRUE от функции первого параметра - is.character().
#Используем функцию str_replace_all из пакета stringr. Она позволяет, использую довольно простой 
#синтаксис, заменить ненужные нам символы:
names(tbl) =  str_replace_all(names(tbl), "[!]","_emph_")
#В данном примере, мы говорим, что теперь все имена таблицы должны быть некоторым вектором строк от 
#функции str_replace_all, которая в свою очередь берет все имена из таблицы tbl, заменяет в них все ! 
#на “emph” и возвращает их в виде вектора. Все довольно наглядно, но проблема в том, что нам нужно 
#сделать такое последовательно много раз(т.к. нам нужно избавиться не только от !), что приведет к 
#совершенно не читаемому результату. Поэтому воспользуеися оператором пайппинга
names(tbl) = names(tbl) %>% 
  str_replace_all("[!]","_emph_") %>% 
  str_replace_all("[?]","_quest_") %>% 
  str_replace_all("[*]","_star_") %>% 
  str_replace_all("[+]","_plus_") %>%
  str_replace_all("[-]","_minus_") %>%
  str_replace_all("[@]","_at_") %>%
  str_replace_all("[$]","_dollar_") %>%
  str_replace_all("[#]","_hash_") %>%
  str_replace_all("[/]","_div_") %>%
  str_replace_all("[%]","_perc_") %>%
  str_replace_all("[&]","_amp_") %>%
  str_replace_all("[\\^]","_power_") %>%
  str_replace_all("[()]","_") 
glimpse(tbl)
#Функция cor работает только с численными данными, поэтому, чтобы перейти к корелляционному анализу 
#нужно выбрать все переменные типа numeric. Для этого воспользуемся двумя функциями - is.numeric(), 
#которая выдает TRUE в случае если вектор является численныи и sapply(), которая берет каждую колонку 
#таблицы, передает ее в функию в виде вектора(в нашем случае этой функцией будет is.numeric) и выдает 
#результат в виде вектора длинной равной количеству колонок в таблице.
sapply(tbl,is.numeric)
#Для каждой колонки таблицы мы получили значение правда, если она является численной и ложь, если не 
#является. Осталось подставить этот вектор в саму таблицу и получить таблицу состояющую только из 
#интересующих нас колонок
tbl_numeric = tbl[,sapply(tbl,is.numeric) ]
#При этом очень легко получить таблицу, содержащую все остальные колонки
tbl_non_numeric = tbl[,!sapply(tbl,is.numeric) ]
#Теперь мы можем переходить к корелляционному анализу
cor_td = cor(tbl_numeric)
cor_td
#Ничего не вышло, проблема в том, что почти каждая из переменных содержит пропуски, а это приводит к 
#тому, что невозможно провести попарную ковариацию, что ячляется первой частью корелляционного 
#анализа. Это означает, что нам необходимо избаиться от все строк где есть хоть одно значение NA. 
#Воспользуемся для этого готовой функцией drop_na()
cor_td = cor(drop_na(tbl_numeric))
cor_td
#Полученные результаты довольно тяжело интерпретировать т.к. они выдаются в виде матрицы, поэтому 
#преобразуем матрицу в таблицу, выберем интересующий нас столбец, а из него возьмем только те имена 
#строк(переменных) для которых значения коэффициента детерминации было больше 0,1
cor_td = cor(drop_na(tbl_numeric)) %>% as.data.frame %>% select(h2o_flux)
vars = row.names(cor_td)[cor_td$h2o_flux^2 > .1] %>% na.exclude
# Собрать все переменные из вектора с именнами переменных в одну формулу можно следующим образом:
formula = as.formula(paste("h2o_flux~", paste(vars,collapse = "+"), sep=""))
formula
#Создать произвольные(возможно пересекающиеся) обучающую и тестирующую выборки можно с помощью 
#команды sample_n из пакета dplyr
teaching_tbl = sample_n(tbl, floor(length(tbl$date)*.7))
testing_tbl = sample_n(tbl, floor(length(tbl$date)*.3))
#Если вы хотите сделать непересекающиеся подвыборки, то это можно сделать базовым набором функций
row_numbers = 1:length(tbl$date)
teach = sample(row_numbers, floor(length(tbl$date)*.7))
test = row_numbers[-teach]

teaching_tbl_unq = tbl[teach,]
testing_tbl_unq = tbl[test,]
